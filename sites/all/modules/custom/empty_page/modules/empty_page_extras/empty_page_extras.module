<?php

/**
 * Implements hook_page_title_api().
 */
function empty_page_extras_page_title_api() {
  return array(
    'api' => 1,
    'path' => drupal_get_path('module', 'empty_page_extras') . '/plugins/page_title',
  );
}

/**
 * Implements hook_menu().
 */
function empty_page_extras_menu() {
  $items = array();

  // Add system settings form.
  $items['admin/structure/empty-page/settings'] = array(
    'title' => 'Settings',
    'description' => 'Administer Empty Page module settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('empty_page_extras_settings_form'),
    'access arguments' => array(EMPTY_PAGE_PERM_ADMIN_CALLBACKS),
    'type' => MENU_LOCAL_TASK,
    'file' => 'empty_page_extras.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function empty_page_extras_menu_alter(&$items) {

  // Optionally add access control to the dynamic callbacks.
  if (variable_get('empty_page_access_control')) {
    foreach (empty_page_get_callbacks() as $callback) {
      $items[$callback->path]['access callback'] = 'empty_page_fetch_access';
      $items[$callback->path]['access arguments'] = array($callback->data);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function empty_page_extras_form_empty_page_callback_edit_form_alter(&$form, &$form_state) {

  // Ensure that any fields we add come before the submit button.
  $form['empty_page_edit']['buttons']['#weight'] = 255;

  // Optionally display access-control settings on the callback-edit form.
  if (variable_get('empty_page_access_control')) {

    // Load callback object using cid stored on the form.
    $cid = isset($form['empty_page_edit']['callback_id']['#value']) ? $form['empty_page_edit']['callback_id']['#value'] : NULL;
    $callback = empty_page_get_callback($cid);

    $form['empty_page_edit']['access_control'] = array(
      '#prefix' => '<div id="empty-page-access-control-settings">',
      '#suffix' => '</div>',
      '#type' => 'fieldset',
      '#title' => t('Access control'),
    );
    $form['empty_page_edit']['access_control']['enable_access_control'] = array(
      '#type' => 'select',
      '#options' => array(t('None'), t('User role')),
      '#default_value' => empty($callback->data['rids']) ? 0 : 1,
      '#ajax' => array(
        'callback' => 'empty_page_extras_access_control_element',
        'wrapper' => 'empty-page-access-control-settings',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );

    $show_roles = isset($form_state['values']['enable_access_control']) ? $form_state['values']['enable_access_control'] : isset($callback->data['rids']);

    if ($show_roles) {
      $form['empty_page_edit']['access_control']['rids'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Select roles that can access this callback:'),
        '#options' => user_roles(),
        // Assumes that if you're enabling a permissions check you want to
        // limit access to authenticated users by default.
        '#default_value' => isset($callback->data['rids']) ? $callback->data['rids'] : array(2),
        '#description' => t("Select 'None' from the dropdown above to disable the permissions check. Unchecking all roles will deny all access to this callback.")
      );
    }

    // Replace main module's submit handler with our own. It's not the most
    // integrated solution, but definitely the 'lightest touch'.
    $handlers = array_flip($form['#submit']);
    $key = isset($handlers['empty_page_callback_edit_form_submit']) ? $handlers['empty_page_callback_edit_form_submit'] : NULL;
    if (isset($key)) {
      $form['#submit'][$key] = 'empty_page_extras_callback_edit_form_submit';
    }
  }
}

/**
 * AJAX callback to display settings fieldset.
 */
function empty_page_extras_access_control_element($form, $form_state) {
  return $form['empty_page_edit']['access_control'];
}

/**
 * Form-submit function to handle saving custom permissions.
 */
function empty_page_extras_callback_edit_form_submit($form, &$form_state) {

  // Create new object from form values. Timestamps are set during save routine.
  $callback = new stdClass();
  $callback->callback_id = $form_state['values']['callback_id'];
  $callback->path = $form_state['values']['path'];
  $callback->page_title = $form_state['values']['page_title'];

  // Populate $data with arrays. Serialization happens just before storage.
  $data = array();
  if (variable_get('empty_page_access_control') && $form_state['values']['enable_access_control']) {
    $data += array('rids' => array_keys(array_filter($form_state['values']['rids'])));
  }
  $callback->data = empty($data) ? NULL : $data;

  // Compare form object to existing records and save/update as necessary.
  switch (empty_page_save_callback($callback)) {
    case SAVED_NEW:
      drupal_set_message(t('Callback created.'));
      break;
    case SAVED_UPDATED:
      drupal_set_message(t('Callback updated.'));
      break;
    default:
      drupal_set_message(t('Error saving callback.'));
      break;
  }

  drupal_goto('admin/structure/empty-page');
}

/**
 * Access check for Empty Page callbacks.
 */
function empty_page_fetch_access($callback_data) {
  if (empty($callback_data)) {
    return TRUE;
  }
  if (isset($callback_data['rids'])) {
    global $user;
    $match = array_intersect($callback_data['rids'], array_keys($user->roles));
    return !empty($match);
  }
}
